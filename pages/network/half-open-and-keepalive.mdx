# half open 과 keep alive

## half open이란?

실제로 상대방과의 연결은 끊겼는데, 나는 상대방과 연결이 끊긴지 모르고 있는 상태

### 일반적인 소켓 연결 종료

- `A` 와 `B` 소켓 통신
- `B` 의 `OS의 안전 종료` 또는 `프로세스 Kill` 발생
- `OS`는 모든 소켓 또는 특정 프로세스가 사용중이던 소켓 종료를 알리는 `FIN` 패킷을 `A`에게 전송
- `A` 는 `FIN` 패킷을 받고 소켓을 끊음

### half open 이 발생하는 종료

- `A` 와 `B` 소켓 통신
- `B` 의 `OS 강제 종료`
- `OS`는 `FIN` 패킷도 못날리고 `즉사`
- `A` 는 `FIN` 패킷을 받은적 없으니, 여전히 소켓을 유지함

### half open 상태에서 request를 보내면

`B` 의 OS 강제 종료로 half open 발생

- `A`가 `B`에게 패킷 전송
- `B`의 응답 없음
- `OS`의 `net.ipv4.tcp_retries2` 값 만큼(`default:15`) 재시도

| 재시도 횟수 | 대기 시간 (RTO) | 누적 경과 시간 (약) |
| :---: | :--- | :--- |
| **1회** | 0.2초 | 0.2초 |
| **2회** | 0.4초 | 0.6초 |
| **3회** | 0.8초 | 1.4초 |
| ... | ... | ... |
| **5회** | 3.2초 | 약 6초 |
| **10회** | 약 1분 | 약 2~3분 |
| **15회 (기본값)** | 약 2분 | **총 합계: 약 924초 (약 15분 24초)** |

- 재시도를 거쳤는데도 응답 없으면 `아.. half open 상태인가보다 연결 끊자` 하고 연결 끊음 (`ETIMEDOUT`)

---

## keep alive 를 사용해서 half-open 방지

OS 기본 

- `net.ipv4.tcp_keepalive_time : 7200ms`
- `net.ipv4.tcp_keepalive_intvl : 75s`
- `net.ipv4.tcp_keepalive_probes : 9`

기준

### 상황 : 서버 리부팅, 프로세스 재시작되었을 때

- 마지막 패킷 발신/수신 이후로 즉시 `idle` 상태로 빠짐
- `idle` 상태가 `7200ms` 유지되면 **첫번째** `Probe` 패킷 발신
- 재부팅 된 서버는 **너가 보낸 패킷에 해당하는 프로세스가 없어 난 몰라** `RST(Reset)` 응답 
- `RST` 응답 받은 나는 **상대방이 나를 기억 못 하는구나(Half-Open).** 소켓 닫음

<Callout type="info" emoji="ℹ️">
실제 경험담
- k8s 환경에서 redis 사용중
- redis pod 강제 종료됨
- keepAlive 설정 안했을때는 강제 종료되었던 redis pod가 올라왔는데도 half open 유지
- keepAliv 설정했을때는 강제 종료되었던 redis pod가 올라오는 순간 `RST 응답`이 와서 half open 종료
</Callout>

### 상황 : 상대방이 아예 사라졌을 때 (No Response - 가장 흔한 Half-Open)

- 마지막 패킷 발신/수신 이후로 즉시 `idle` 상태로 빠짐
- `idle` 상태가 `7200ms` 유지되면 **첫번째** `Probe` 패킷 발신
- **상대방 응답이 없으면** `net.ipv4.tcp_keepalive_intvl : 75s` 뒤에 **두번째** `Probe` 패킷 발신
- 또 **상대방 응답이 없으면** 세번째, 네번째 ~  `최대net.ipv4.tcp_keepalive_probes` 만큼 반복
- 결국 최종적으로 응답 없으면 `어? 연결 끊어졌네?` 하고 소켓을 닫음


